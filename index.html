<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ultimate Cleverbot AI</title>
<style>
body {
  font-family: sans-serif;
  background: #f4f4f4;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  margin: 0;
}
#chat {
  width: 600px;
  height: 650px;
  background: #fff;
  border: 1px solid #ccc;
  padding: 10px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}
.message {
  margin: 5px 0;
  padding: 8px 12px;
  border-radius: 10px;
  max-width: 80%;
  word-wrap: break-word;
}
.user {
  background: #cce5ff;
  align-self: flex-end;
}
.ai {
  background: #e2e3e5;
  align-self: flex-start;
}
#inputForm {
  display: flex;
  margin-top: 10px;
}
#userInput {
  flex: 1;
  padding: 8px;
  border-radius: 5px;
  border: 1px solid #ccc;
}
#sendBtn {
  padding: 8px 12px;
  margin-left: 5px;
  border-radius: 5px;
  border: none;
  background: #007bff;
  color: white;
  cursor: pointer;
}
</style>
</head>
<body>
<div>
  <div id="chat"></div>
  <form id="inputForm">
    <input type="text" id="userInput" placeholder="Type a message..." autocomplete="off"/>
    <button type="submit" id="sendBtn">Send</button>
  </form>
</div>

<script>
// ====================== UTILITY FUNCTIONS ======================
function tokenize(text){
  return text.toLowerCase().split(/\s+/).map(t => t.replace(/[^\w]/g,'')).filter(Boolean);
}

// Cosine similarity
function cosineSim(a,b){
  const dict = {};
  a.forEach(word=>dict[word]=(dict[word]||0)+1);
  let dot=0,normA=0,normB=0;
  Object.keys(dict).forEach(k=>{
    const x=a.filter(w=>w===k).length;
    const y=b.filter(w=>w===k).length;
    dot+=x*y; normA+=x*x; normB+=y*y;
  });
  return dot / (Math.sqrt(normA)*Math.sqrt(normB)+0.00001);
}

// Jaccard similarity
function jaccardSim(a,b){
  const setA=new Set(a);
  const setB=new Set(b);
  const inter=new Set([...setA].filter(x=>setB.has(x)));
  const union=new Set([...setA,...setB]);
  return inter.size / (union.size || 1);
}

// Levenshtein/char distance similarity
function charSim(a,b){
  a=a.join(''); b=b.join('');
  const len=Math.max(a.length,b.length);
  if(len===0) return 1;
  let diff=0;
  for(let i=0;i<len;i++){
    if(a[i]!==b[i]) diff++;
  }
  return 1-diff/len;
}

// Weighted random selection
function weightedChoice(choices,weights){
  const sum=weights.reduce((a,b)=>a+b,0);
  let r=Math.random()*sum;
  for(let i=0;i<choices.length;i++){
    if(r<weights[i]) return choices[i];
    r-=weights[i];
  }
  return choices[choices.length-1];
}

// Emotion detection
function detectEmotion(text){
  text=text.toLowerCase();
  if(/happy|good|great|awesome|fun|love/.test(text)) return 'happy';
  if(/sad|bad|angry|upset|hate/.test(text)) return 'sad';
  if(/excited|wow|amazing|cool/.test(text)) return 'excited';
  return 'neutral';
}

// ====================== TEMP MEMORY ======================
const tempMemory=[];
const maxMemory=50; // store last 50 exchanges

// ====================== DATASET ======================
// Paste 1000+ Q/A pairs here
const dataset=[
  {input:"hi",output:"Hello! How's it going?"},
  {input:"hello",output:"Hi there!"},
  {input:"how are you?",output:"I'm doing well, thanks! How about you?"},
  {input:"what is your name?",output:"I am an AI chatbot created from scratch."},
  {input:"tell me a joke",output:"Why did the chicken cross the road? To get to the other side!"},
  {input:"goodbye",output:"See you later!"},
  {input:"who are you?",output:"I'm your personal AI assistant."},
  {input:"what is AI?",output:"AI stands for artificial intelligence, like me!"},
  {input:"do you like music?",output:"I enjoy learning about music."},
  // ... expand to 1000+ entries
];

  // ====================== CLEVERBOT AI ENGINE ======================

// Weighted scoring constants
const COS_WEIGHT = 0.4;
const JACCARD_WEIGHT = 0.35;
const CHAR_WEIGHT = 0.25;

// Confidence thresholds
const HIGH_CONF = 750;   // 0-1000 scale
const MED_CONF = 400;

// Max previous exchanges to consider in chain
const CHAIN_LENGTH = 10;

// Helper: compute total weighted similarity (0-1000)
function computeWeightedScore(userTokens, pairTokens){
    const cos = cosineSim(userTokens,pairTokens);
    const jac = jaccardSim(userTokens,pairTokens);
    const ch = charSim(userTokens,pairTokens);
    return Math.floor( (cos*COS_WEIGHT + jac*JACCARD_WEIGHT + ch*CHAR_WEIGHT) * 1000 );
}

// Helper: get chain influence score
function chainInfluence(pairInput){
    let scoreBoost = 0;
    for(let i=tempMemory.length-1;i>=0;i--){
        const mem = tempMemory[i];
        if(mem.user && pairInput){
            const tokensUser = tokenize(mem.user);
            const tokensPair = tokenize(pairInput);
            const similarity = computeWeightedScore(tokensUser,tokensPair)/1000; // 0-1
            scoreBoost += similarity*( (CHAIN_LENGTH-(tempMemory.length-1-i))/CHAIN_LENGTH );
        }
    }
    return Math.floor(scoreBoost*200); // chain influence adds up to 200 max
}

// Medium-match cleverbot style selection
function selectReplyWeighted(candidates){
    // Separate high/medium/low
    const high = candidates.filter(c=>c.score>=HIGH_CONF);
    const medium = candidates.filter(c=>c.score>=MED_CONF && c.score<HIGH_CONF);
    const low = candidates.filter(c=>c.score<MED_CONF);

    if(high.length>0) return weightedChoice(high, high.map(c=>c.score));
    if(medium.length>0) return weightedChoice(medium, medium.map(c=>c.score));
    if(low.length>0) return weightedChoice(low, low.map(c=>c.score));
    return {reply:"I'm not sure how to respond to that.", score:0};
}

// Main AI function
async function cleverbotAI(userText){
    const tokens = tokenize(userText);
    let candidates=[];

    dataset.forEach(pair=>{
        const pairTokens = tokenize(pair.input);
        let score = computeWeightedScore(tokens,pairTokens);
        score += chainInfluence(pair.input); // add chain memory influence
        candidates.push({reply:pair.output, score});
    });

    // Sort by score descending
    candidates.sort((a,b)=>b.score-a.score);

    // Select reply via medium-match cleverbot-style
    let best = selectReplyWeighted(candidates);
    let bestReply = best.reply;
    let confidence = best.score;

    // Temp memory chain lookup for exact repeat
    for(let i=tempMemory.length-1;i>=0;i--){
        const mem=tempMemory[i];
        if(mem.user===userText){
            bestReply = mem.ai + " (remembered)";
            confidence = 1000; // max confidence for exact repeat
            break;
        }
    }

    // Low confidence fallback: search via Cloudflare Worker
    if(confidence<MED_CONF){
        try{
            const res = await fetch(`https://soft-rain-235f.younglin90.workers.dev/?q=${encodeURIComponent(userText)}`);
            const data = await res.json();
            if(data.organic_results && data.organic_results.length>0){
                bestReply = data.organic_results[0].snippet || bestReply;
                confidence += 100; // slight boost if fallback used
            }
        }catch(e){}
    }

    // Emotion detection affects tone
    const emotion = detectEmotion(userText);
    if(emotion==='happy') bestReply = "ðŸ˜Š "+bestReply;
    if(emotion==='sad') bestReply = "ðŸ˜Ÿ "+bestReply;
    if(emotion==='excited') bestReply = "ðŸ¤© "+bestReply;

    // Store in temp memory
    tempMemory.push({user:userText, ai:bestReply});
    if(tempMemory.length>maxMemory) tempMemory.shift();

    return bestReply;
}

// ====================== CHAT UI HOOK ======================
const chat=document.getElementById('chat');
const form=document.getElementById('inputForm');
const input=document.getElementById('userInput');

form.addEventListener('submit', async e=>{
    e.preventDefault();
    const userText = input.value.trim();
    if(!userText) return;
    addMessage('user',userText);
    input.value='';

    const reply = await cleverbotAI(userText);
    addMessage('ai',reply);
});

function addMessage(sender,text){
    const div=document.createElement('div');
    div.classList.add('message',sender);
    div.textContent=text;
    chat.appendChild(div);
    chat.scrollTop=chat.scrollHeight;
}

  // ====================== ADVANCED MEMORY & LEARNING ======================

// Decay factor for older memories (older exchanges have less influence)
const DECAY_RATE = 0.85;

// Function to propagate learning influence from recent exchanges
function propagateLearning(){
    for(let i=tempMemory.length-1; i>=0; i--){
        const mem=tempMemory[i];
        if(!mem.user || !mem.ai) continue;
        // Slightly adjust dataset weights (pseudo-learning)
        dataset.forEach(pair=>{
            if(pair.input.toLowerCase()===mem.user.toLowerCase()){
                // Increase relevance score (simulated learning)
                pair.weight = (pair.weight||1) + 0.1 * Math.pow(DECAY_RATE, tempMemory.length-1-i);
            }
        });
    }
}

// Function to get dataset weight for scoring (1 default)
function getPairWeight(pair){
    return pair.weight || 1;
}

// Enhanced computeWeightedScore with dynamic learning influence
function computeWeightedScoreWithLearning(userTokens, pairTokens, pair){
    let baseScore = computeWeightedScore(userTokens, pairTokens);
    const weight = getPairWeight(pair);
    return Math.min(baseScore * weight, 1000); // max score 1000
}

// Modified cleverbotAI to include learning propagation
async function cleverbotAIWithLearning(userText){
    const tokens = tokenize(userText);
    let candidates=[];

    dataset.forEach(pair=>{
        const pairTokens = tokenize(pair.input);
        let score = computeWeightedScoreWithLearning(tokens,pairTokens,pair);
        score += chainInfluence(pair.input); // add chain memory influence
        candidates.push({reply:pair.output, score});
    });

    // Sort and select best reply
    candidates.sort((a,b)=>b.score-a.score);
    let best = selectReplyWeighted(candidates);
    let bestReply = best.reply;
    let confidence = best.score;

    // Exact repeat check
    for(let i=tempMemory.length-1;i>=0;i--){
        const mem=tempMemory[i];
        if(mem.user===userText){
            bestReply = mem.ai + " (remembered)";
            confidence = 1000;
            break;
        }
    }

    // Low confidence fallback
    if(confidence<MED_CONF){
        try{
            const res = await fetch(`https://soft-rain-235f.younglin90.workers.dev/?q=${encodeURIComponent(userText)}`);
            const data = await res.json();
            if(data.organic_results && data.organic_results.length>0){
                bestReply = data.organic_results[0].snippet || bestReply;
                confidence += 100;
            }
        }catch(e){}
    }

    // Emotion adjustment
    const emotion = detectEmotion(userText);
    if(emotion==='happy') bestReply = "ðŸ˜Š "+bestReply;
    if(emotion==='sad') bestReply = "ðŸ˜Ÿ "+bestReply;
    if(emotion==='excited') bestReply = "ðŸ¤© "+bestReply;

    // Store in temp memory
    tempMemory.push({user:userText, ai:bestReply});
    if(tempMemory.length>maxMemory) tempMemory.shift();

    // Propagate learning influence after storing
    propagateLearning();

    return bestReply;
}

// ====================== CHAT HOOK OVERRIDE ======================
// Replace previous form listener to use learning version
form.removeEventListener('submit',()=>{}); // just in case
form.addEventListener('submit', async e=>{
    e.preventDefault();
    const userText = input.value.trim();
    if(!userText) return;
    addMessage('user',userText);
    input.value='';

    const reply = await cleverbotAIWithLearning(userText);
    addMessage('ai',reply);
});

  // ====================== FINAL UTILITIES & CONTEXT ======================

// Conversation context logger (optional, can store locally)
let conversationLog = []; // {user:..., ai:..., timestamp:...}
function logConversation(userText, aiReply){
    const ts = new Date().toISOString();
    conversationLog.push({user:userText, ai:aiReply, timestamp:ts});
    // Keep only last 200 logs
    if(conversationLog.length>200) conversationLog.shift();
}

// Anti-loop detection
function preventLoops(reply){
    // If last AI message is identical, append variation
    if(tempMemory.length>1 && tempMemory[tempMemory.length-2].ai===reply){
        reply += " (â€¦let me think a bit differently)";
    }
    return reply;
}

// Overriding addMessage to include logging
function addMessage(sender,text){
    text = preventLoops(text);
    const div=document.createElement('div');
    div.classList.add('message',sender);
    div.textContent=text;
    chat.appendChild(div);
    chat.scrollTop=chat.scrollHeight;

    // log conversation
    if(sender==='ai'){
        const lastUser = tempMemory.length>0 ? tempMemory[tempMemory.length-1].user : "";
        logConversation(lastUser,text);
    }
}

// Optional: function to clear memory
function clearMemory(){
    tempMemory.length = 0;
    conversationLog.length = 0;
}

// Optional: function to simulate learning from bulk dataset
function bulkLearn(newPairs){
    newPairs.forEach(pair=>{
        if(!dataset.find(p=>p.input===pair.input)){
            dataset.push(pair);
        }
    });
}

// ====================== END OF AI SYSTEM ======================
// Your HTML + UI + AI engine + advanced memory + learning + search fallback
// is now fully integrated. Just paste your dataset into the dataset array
// in Part 1 to make it fully functional with 1000+ entries.

// ====================== HOW TO USE ======================
// Type in the input box and press "Send". AI will:
// 1. Use weighted similarity (0-1000 scale)
// 2. Include last N exchanges for context (chain weighting)
// 3. Apply medium-match randomness
// 4. Detect emotion and adjust tone
// 5. Check memory for repeats
// 6. Use search fallback if low confidence
// 7. Log conversation and prevent simple loops
</script>
